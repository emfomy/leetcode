// Source: https://leetcode.com/problems/count-square-sum-triples
// Title: Count Square Sum Triples
// Difficulty: Easy
// Author: Mu Yang <http://muyang.pro>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A **square triple** `(a,b,c)` is a triple where `a`, `b`, and `c` are **integers** and `a^2 + b^2 = c^2`.
//
// Given an integer `n`, return the number of **square triples** such that `1 <= a, b, c <= n`.
//
// **Example 1:**
//
// ```
// Input: n = 5
// Output: 2
// Explanation
// : The square triples are (3,4,5) and (4,3,5).
// ```
//
// **Example 2:**
//
// ```
// Input: n = 10
// Output: 4
// Explanation
// : The square triples are (3,4,5), (4,3,5), (6,8,10), and (8,6,10).
// ```
//
// **Constraints:**
//
// - `1 <= n <= 250`
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <cmath>
#include <numeric>

using namespace std;

// Counting
class Solution {
 public:
  int countTriples(int n) {
    auto ans = 0;
    for (auto a = 1; a <= n; ++a) {
      for (auto b = 1; b <= n; ++b) {
        int c = sqrt(a * a + b * b);
        if (c > n) break;
        ans += (a * a + b * b == c * c);
      }
    }
    return ans;
  }
};

// Math, Euclid's Formula
//
// First we observe that a != b since sqrt(2) is irrational.
//
// We can generate *Pythagorean Triples* (a, b, c) by
// a = u^2-v^2
// b = 2uv
// c = u^2+v^2
// Note that u > v >= 1.
//
// All valid triples can be generated by multiplying *Primitive* Pythagorean Triples.
// A triple is called primitive iff. (u, v) are coprime and (u, v) have opposite parity (odd/even, even/odd).
//
// For example, let (u, v) = (2, 1), (a, b, c) = (3, 4, 5).
// We can scale it to (6, 8, 10), (9, 12, 15), ...
//
// Why do we need Primitive Triple? Since it ensures no duplication during the generation.
// Why start at u = 2? Ensure u > v (for a > 0).
class Solution2 {
 public:
  int countTriples(int n) {
    auto ans = 0;
    for (auto u = 2; u * u <= n; ++u) {
      for (auto v = 1; v < u; ++v) {
        if ((u - v) % 2 == 0 || gcd(u, v) != 1) continue;  // check parity and coprime
        auto c = u * u + v * v;
        if (c > n) break;    // v too large
        ans += 2 * (n / c);  // count multiples
      }
    }
    return ans;
  }
};
